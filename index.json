[{"content":"Go语言设计和应用模式\n创作模式 \u0026lt; 建造者模式 \u0026gt; 建造者模式将复杂对象的构造与其表示分离，使得相同的构造过程可以创建不同的表示。\n在 Go 中，通常使用配置结构来实现相同的行为，但是将结构传递给构建器方法会使用样板 if cfg.Field != nil {...}检查填充代码\n示例 package car type Speed float64 const ( MPH Speed = 1 KPH = 1.60934 ) type Color string const ( BlueColor Color = \u0026#34;blue\u0026#34; GreenColor = \u0026#34;green\u0026#34; RedColor = \u0026#34;red\u0026#34; ) type Wheels string const ( SportsWheels Wheels = \u0026#34;sports\u0026#34; SteelWheels = \u0026#34;steel\u0026#34; ) type Builder interface { Color(Color) Builder Wheels(Wheels) Builder TopSpeed(Speed) Builder Build() Interface } type Interface interface { Drive() error Stop() error } 用法 assembly := car.NewBuilder().Paint(car.RedColor) familyCar := assembly.Wheels(car.SportsWheels).TopSpeed(50 * car.MPH).Build() familyCar.Drive() sportsCar := assembly.Wheels(car.SteelWheels).TopSpeed(150 * car.MPH).Build() sportsCar.Drive() \u0026lt; 工厂模式 \u0026gt; 工厂方法创建设计模式允许创建对象而不必指定将要创建的对象的确切类型。\n示例实现展示了如何提供具有不同后端（例如内存、磁盘存储）的数据存储。\n示例 package data import \u0026#34;io\u0026#34; type Store interface { Open(string) (io.ReadWriteCloser, error) } type StorageType int const ( DiskStorage StorageType = 1 \u0026lt;\u0026lt; iota TempStorage MemoryStorage ) func NewStore(t StorageType) Store { switch t { case MemoryStorage: return newMemoryStorage( /*...*/ ) case DiskStorage: return newDiskStorage( /*...*/ ) default: return newTempStorage( /*...*/ ) } } 用法 s, _ := data.NewStore(data.MemoryStorage) f, _ := s.Open(\u0026#34;file\u0026#34;) n, _ := f.Write([]byte(\u0026#34;data\u0026#34;)) defer f.Close() 对象池模式 对象池创建设计模式用于根据需求预期准备和保留多个实例。\n对象池模式在对象初始化比对象维护更昂贵的情况下很有用。 如果需求出现峰值而不是稳定需求，则维护开销可能会超过对象池的好处。 由于预先初始化对象，它对性能有积极影响。 示例 package pool type Pool chan *Object func New(total int) *Pool { p := make(Pool, total) for i := 0; i \u0026lt; total; i++ { p \u0026lt;- new(Object) } return \u0026amp;p } 用法\np := pool.New(2) select { case obj := \u0026lt;-p: obj.Do( /*...*/ ) p \u0026lt;- obj default: // No more objects left — retry later or fail return } 单例模式 单例创建设计模式将类型的实例化限制为单个对象。\n单例模式表示全局状态，大多数时候会降低可测试性。 示例 package singleton type singleton map[string]string var ( once sync.Once instance singleton ) func New() singleton { once.Do(func() { instance = make(singleton) }) return instance } 用法 s := singleton.New() s[\u0026#34;this\u0026#34;] = \u0026#34;that\u0026#34; s2 := singleton.New() fmt.Println(\u0026#34;This is \u0026#34;, s2[\u0026#34;this\u0026#34;]) // This is that ","permalink":"https://yanyiup.com/posts/tech/go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F/","summary":"Go语言设计和应用模式 创作模式 \u0026lt; 建造者模式 \u0026gt; 建造者模式将复杂对象的构造与其表示分离，使得相同的构造过程可以创建不同的表示。 在 Go 中，通常使用配","title":"Go语言设计和应用模式"},{"content":"","permalink":"https://yanyiup.com/about/","summary":"","title":"个人信息"}]