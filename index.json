[{"content":"1、创建Redis集群配置文件模版。cluster-redis.conf # redis端口 port ${PORT} # ip bind 0.0.0.0 # 关闭本地访问保护模式 protected-mode no # 设置的密码 requirepass 123456 # 开启集群功能 cluster-enabled yes # 集群节点配置的文件名,非人工编写,由程序自动生成和修改 cluster-config-file nodes.conf # 集群节点超时时间,配合 cluster-replica-validity-factor 使用 cluster-node-timeout 1000 # 探测集群节点超时不可用的次数,假设cluster-node-timeout 设置的 1000ms,cluster-replica-validity-factor 为 5, 那么1000*5之间 cluster-replica-validity-factor 5 # 主从节点下最少的从节点数 cluster-migration-barrier 1 # yes 要求所有主节点正常工作,且所有 hash slots 被分配到工作的主节点,集群才能提供服务,如果想一部分 hash slots 即可响应请求,则设置为 no cluster-require-full-coverage no # yes 禁止当主节点挂掉时,让从节点不能竞选为主节点 cluster-replica-no-failover no # 集群节点IP host模式为宿主机IP #------------特别注意----------------- cluster-announce-ip 此处配置宿主机ip cluster-announce-port ${PORT} cluster-announce-bus-port 1${PORT} # rdb 策略 # save “” 关闭 rdb # 900s内至少一次写操作则执行bgsave进行rdb持久化 save 900 1 save 300 10 save 60 10000 # rdb 压缩 默认yes 消耗 cpu rdbcompression yes # 保存rdb文件的时候，进行错误检查校验，默认yes rdbchecksum yes # 指定rdb文件的名称，默认 dump.rdb dbfilename dump.rdb # aof策略 appendonly no #1.no 依靠 os 进行刷新，redis 不主动刷新 AOF，这样最快，不过安全性就差。 #2.always 没提交一个修改命令都调用 fsync 刷新到 AOF 文件，非常非常慢，但也非常安全。 #3.everysec 每秒钟调用 fsync 刷新到 AOF 文件，很快，但可能会丢失 1 秒内的数据。 appendfsync everysec # 指定 AOF 文件的名称，默认为 appendonly.aof appendfilename appendonly.aof # 设置 RDB 和 AOF 文件的目录 dir /data 2、构建各个配置文件脚本。generate.sh for port in $(seq 7001 7006); do mkdir -p ./redis-cluster/${port}/conf \u0026amp;\u0026amp; PORT=${port} envsubst \u0026lt;./cluster-redis.conf \u0026gt;./redis-cluster/${port}/conf/redis.conf \u0026amp;\u0026amp; mkdir -p ./redis-cluster/${port}/data done 3、创建docker-compose.yml文件 version: \u0026#34;3.8\u0026#34; services: redis01: image: redis:6.2.6 container_name: redis01 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: rd_net: ipv4_address: 172.18.0.2 ports: - \u0026#34;7001:7001\u0026#34; - \u0026#34;17001:17001\u0026#34; volumes: - ./redis-cluster/7001/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7001/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis02: image: redis:6.2.6 container_name: redis02 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: rd_net: ipv4_address: 172.18.0.3 ports: - \u0026#34;7002:7002\u0026#34; - \u0026#34;17002:17002\u0026#34; volumes: - ./redis-cluster/7002/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7002/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis03: image: redis:6.2.6 container_name: redis03 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: rd_net: ipv4_address: 172.18.0.4 ports: - \u0026#34;7003:7003\u0026#34; - \u0026#34;17003:17003\u0026#34; volumes: - ./redis-cluster/7003/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7003/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis04: image: redis:6.2.6 container_name: redis04 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: rd_net: ipv4_address: 172.18.0.5 ports: - \u0026#34;7004:7004\u0026#34; - \u0026#34;17004:17004\u0026#34; volumes: - ./redis-cluster/7004/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7004/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis05: image: redis:6.2.6 container_name: redis05 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: rd_net: ipv4_address: 172.18.0.6 ports: - \u0026#34;7005:7005\u0026#34; - \u0026#34;17005:17005\u0026#34; volumes: - ./redis-cluster/7005/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7005/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis06: image: redis:6.2.6 container_name: redis06 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: rd_net: ipv4_address: 172.18.0.7 ports: - \u0026#34;7006:7006\u0026#34; - \u0026#34;17006:17006\u0026#34; volumes: - ./redis-cluster/7006/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7006/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] networks: rd_net: driver: bridge name: rd_net ipam: config: - subnet: 172.18.0.0/16 gateway: 172.18.0.1 4、构建Redis节点 docker-compose up -d 5、进入任意容器 docker exec -it 容器ID bash 6、集群搭建指令 redis-cli -p 7001 -a 123456 --cluster create 172.18.0.2:7001 172.18.0.3:7002 172.18.0.4:7003 172.18.0.5:7004 172.18.0.6:7005 172.18.0.7:7006 --cluster-replicas 1 问题 # 如果出现一下输出,输入yes回车 Warning: Using a password with \u0026#39;-a\u0026#39; or \u0026#39;-u\u0026#39; option on the command line interface may not be safe. \u0026gt;\u0026gt;\u0026gt; Performing hash slots allocation on 6 nodes... Master[0] -\u0026gt; Slots 0 - 5460 Master[1] -\u0026gt; Slots 5461 - 10922 Master[2] -\u0026gt; Slots 10923 - 16383 Adding replica 172.18.0.6:7005 to 172.18.0.2:7001 Adding replica 172.18.0.7:7006 to 172.18.0.3:7002 Adding replica 172.18.0.5:7004 to 172.18.0.4:7003 M: 707eb6a1433a9d9de347e1e2e64a3edb4055ee01 172.18.0.2:7001 slots:[0-5460] (5461 slots) master M: 5986cc114c074cdc8024d478fc47429cfa8bede7 172.18.0.3:7002 slots:[5461-10922] (5462 slots) master M: 369006a51afdc40286fd22be672e5cbe9dc17b9d 172.18.0.4:7003 slots:[10923-16383] (5461 slots) master S: c1c5fdcc86a6850ce9426fe26e558a8bff2f68ae 172.18.0.5:7004 replicates 369006a51afdc40286fd22be672e5cbe9dc17b9d S: a80b505b670d60139506f8f6b494cd2e9fa9d801 172.18.0.6:7005 replicates 707eb6a1433a9d9de347e1e2e64a3edb4055ee01 S: a4f924c5c4e1c64056fcff7d92574ea50cbc336b 172.18.0.7:7006 replicates 5986cc114c074cdc8024d478fc47429cfa8bede7 Can I set the above configuration? (type \u0026#39;yes\u0026#39; to accept): yes \u0026gt;\u0026gt;\u0026gt; Nodes configuration updated \u0026gt;\u0026gt;\u0026gt; Assign a different config epoch to each node \u0026gt;\u0026gt;\u0026gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join 成功 \u0026gt;\u0026gt;\u0026gt; Performing Cluster Check (using node 172.18.0.2:7001) M: 707eb6a1433a9d9de347e1e2e64a3edb4055ee01 172.18.0.2:7001 slots:[0-5460] (5461 slots) master 1 additional replica(s) S: c1c5fdcc86a6850ce9426fe26e558a8bff2f68ae 192.168.11.148:7004 slots: (0 slots) slave replicates 369006a51afdc40286fd22be672e5cbe9dc17b9d M: 369006a51afdc40286fd22be672e5cbe9dc17b9d 192.168.11.148:7003 slots:[10923-16383] (5461 slots) master 1 additional replica(s) S: a4f924c5c4e1c64056fcff7d92574ea50cbc336b 192.168.11.148:7006 slots: (0 slots) slave replicates 5986cc114c074cdc8024d478fc47429cfa8bede7 M: 5986cc114c074cdc8024d478fc47429cfa8bede7 192.168.11.148:7002 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: a80b505b670d60139506f8f6b494cd2e9fa9d801 192.168.11.148:7005 slots: (0 slots) slave replicates 707eb6a1433a9d9de347e1e2e64a3edb4055ee01 [OK] All nodes agree about slots configuration. \u0026gt;\u0026gt;\u0026gt; Check for open slots... \u0026gt;\u0026gt;\u0026gt; Check slots coverage... [OK] All 16384 slots covered. 查看搭建情况 # 进入任意容器，输入以下命令 # 进入Redis集群 redis-cli -p 7001 -a 123456 # 查看集群状态 cluster info # 查看集群节点信息 cluster nodes ","permalink":"https://yanyiup.com/posts/tech/%E4%BD%BF%E7%94%A8docker%E6%9E%84%E5%BB%BAredis%E9%9B%86%E7%BE%A4/","summary":"1、创建Redis集群配置文件模版。cluster-redis.conf # redis端口 port ${PORT} # ip bind 0.0.0.0 # 关闭本地访问保护模式 protected-mode no # 设置的密码 requirepass","title":"使用Docker构建Redis集群"},{"content":"Go语言设计和应用模式\n创作模式 建造者模式 建造者模式将复杂对象的构造与其表示分离，使得相同的构造过程可以创建不同的表示。\n在 Go 中，通常使用配置结构来实现相同的行为，但是将结构传递给构建器方法会使用样板 if cfg.Field != nil {...}检查填充代码\n示例 package car type Speed float64 const ( MPH Speed = 1 KPH = 1.60934 ) type Color string const ( BlueColor Color = \u0026#34;blue\u0026#34; GreenColor = \u0026#34;green\u0026#34; RedColor = \u0026#34;red\u0026#34; ) type Wheels string const ( SportsWheels Wheels = \u0026#34;sports\u0026#34; SteelWheels = \u0026#34;steel\u0026#34; ) type Builder interface { Color(Color) Builder Wheels(Wheels) Builder TopSpeed(Speed) Builder Build() Interface } type Interface interface { Drive() error Stop() error } 用法 assembly := car.NewBuilder().Paint(car.RedColor) familyCar := assembly.Wheels(car.SportsWheels).TopSpeed(50 * car.MPH).Build() familyCar.Drive() sportsCar := assembly.Wheels(car.SteelWheels).TopSpeed(150 * car.MPH).Build() sportsCar.Drive() 工厂模式 工厂方法创建设计模式允许创建对象而不必指定将要创建的对象的确切类型。\n示例实现展示了如何提供具有不同后端（例如内存、磁盘存储）的数据存储。\n示例 package data import \u0026#34;io\u0026#34; type Store interface { Open(string) (io.ReadWriteCloser, error) } type StorageType int const ( DiskStorage StorageType = 1 \u0026lt;\u0026lt; iota TempStorage MemoryStorage ) func NewStore(t StorageType) Store { switch t { case MemoryStorage: return newMemoryStorage( /*...*/ ) case DiskStorage: return newDiskStorage( /*...*/ ) default: return newTempStorage( /*...*/ ) } } 用法 s, _ := data.NewStore(data.MemoryStorage) f, _ := s.Open(\u0026#34;file\u0026#34;) n, _ := f.Write([]byte(\u0026#34;data\u0026#34;)) defer f.Close() 对象池模式 对象池创建设计模式用于根据需求预期准备和保留多个实例。\n对象池模式在对象初始化比对象维护更昂贵的情况下很有用。 如果需求出现峰值而不是稳定需求，则维护开销可能会超过对象池的好处。 由于预先初始化对象，它对性能有积极影响。 示例 package pool type Pool chan *Object func New(total int) *Pool { p := make(Pool, total) for i := 0; i \u0026lt; total; i++ { p \u0026lt;- new(Object) } return \u0026amp;p } 用法 p := pool.New(2) select { case obj := \u0026lt;-p: obj.Do( /*...*/ ) p \u0026lt;- obj default: // No more objects left — retry later or fail return } 单例模式 单例创建设计模式将类型的实例化限制为单个对象。\n单例模式表示全局状态，大多数时候会降低可测试性。 示例 package singleton type singleton map[string]string var ( once sync.Once instance singleton ) func New() singleton { once.Do(func() { instance = make(singleton) }) return instance } 用法 s := singleton.New() s[\u0026#34;this\u0026#34;] = \u0026#34;that\u0026#34; s2 := singleton.New() fmt.Println(\u0026#34;This is \u0026#34;, s2[\u0026#34;this\u0026#34;]) // This is that ","permalink":"https://yanyiup.com/posts/tech/go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F/","summary":"Go语言设计和应用模式 创作模式 建造者模式 建造者模式将复杂对象的构造与其表示分离，使得相同的构造过程可以创建不同的表示。 在 Go 中，通常使用配置结","title":"Go语言设计和应用模式"},{"content":"","permalink":"https://yanyiup.com/about/","summary":"","title":"个人信息"}]