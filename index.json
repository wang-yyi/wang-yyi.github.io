[{"content":"1、创建Redis集群配置文件模版。cluster-redis.conf # redis端口 port ${PORT} # ip bind 0.0.0.0 # 关闭本地访问保护模式 protected-mode no # 设置的密码 requirepass 123456 # 开启集群功能 cluster-enabled yes # 集群节点配置的文件名,非人工编写,由程序自动生成和修改 cluster-config-file nodes.conf # 集群节点超时时间,配合 cluster-replica-validity-factor 使用 cluster-node-timeout 1000 # 探测集群节点超时不可用的次数,假设cluster-node-timeout 设置的 1000ms,cluster-replica-validity-factor 为 5, 那么1000*5之间 cluster-replica-validity-factor 5 # 主从节点下最少的从节点数 cluster-migration-barrier 1 # yes 要求所有主节点正常工作,且所有 hash slots 被分配到工作的主节点,集群才能提供服务,如果想一部分 hash slots 即可响应请求,则设置为 no cluster-require-full-coverage no # yes 禁止当主节点挂掉时,让从节点不能竞选为主节点 cluster-replica-no-failover no # 集群节点IP host模式为宿主机IP #------------特别注意----------------- cluster-announce-ip 此处配置宿主机ip # 集群节点端口 7001 - 7006 cluster-announce-port ${PORT} cluster-announce-bus-port 1${PORT} # rdb 策略 # save “” 关闭 rdb # 900s内至少一次写操作则执行bgsave进行rdb持久化 save 900 1 save 300 10 save 60 10000 # rdb 压缩 默认yes 消耗 cpu rdbcompression yes # 保存rdb文件的时候，进行错误检查校验，默认yes rdbchecksum yes # 指定rdb文件的名称，默认 dump.rdb dbfilename dump.rdb # aof策略 appendonly no #1.no 依靠 os 进行刷新，redis 不主动刷新 AOF，这样最快，不过安全性就差。 #2.always 没提交一个修改命令都调用 fsync 刷新到 AOF 文件，非常非常慢，但也非常安全。 #3.everysec 每秒钟调用 fsync 刷新到 AOF 文件，很快，但可能会丢失 1 秒内的数据。 appendfsync everysec # 指定 AOF 文件的名称，默认为 appendonly.aof appendfilename appendonly.aof # 设置 RDB 和 AOF 文件的目录 dir /data 2、构建各个配置文件脚本。generate.sh for port in $(seq 7001 7006); do \\ mkdir -p ./redis-cluster/${port}/conf \\ \u0026amp;\u0026amp; PORT=${port} envsubst \u0026lt; ./cluster-redis.conf \u0026gt; ./redis-cluster/${port}/conf/redis.conf \\ \u0026amp;\u0026amp; mkdir -p ./redis-cluster/${port}/data; \\ done 3、创建docker-compose.yml文件 version: \u0026#34;3.8\u0026#34; services: redis1: image: redis:6.2.6 container_name: redis1 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: - rd_net ports: - \u0026#34;7001:7001\u0026#34; - \u0026#34;17001:17001\u0026#34; volumes: - ./redis-cluster/7001/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7001/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis2: image: redis:6.2.6 container_name: redis2 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: - rd_net ports: - \u0026#34;7002:7002\u0026#34; - \u0026#34;17002:17002\u0026#34; volumes: - ./redis-cluster/7002/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7002/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis3: image: redis:6.2.6 container_name: redis3 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: - rd_net ports: - \u0026#34;7003:7003\u0026#34; - \u0026#34;17003:17003\u0026#34; volumes: - ./redis-cluster/7003/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7003/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis4: image: redis:6.2.6 container_name: redis4 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: - rd_net ports: - \u0026#34;7004:7004\u0026#34; - \u0026#34;17004:17004\u0026#34; volumes: - ./redis-cluster/7004/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7004/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis5: image: redis:6.2.6 container_name: redis5 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: - rd_net ports: - \u0026#34;7005:7005\u0026#34; - \u0026#34;17005:17005\u0026#34; volumes: - ./redis-cluster/7005/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7005/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] redis6: image: redis:6.2.6 container_name: redis6 restart: unless-stopped environment: TZ: Asia/Shanghai LANG: en_US.UTF-8 REDIS_PASSWORD: 123456 networks: - rd_net ports: - \u0026#34;7006:7006\u0026#34; - \u0026#34;17006:17006\u0026#34; volumes: - ./redis-cluster/7006/conf/redis.conf:/etc/redis/redis.conf - ./redis-cluster/7006/data:/data command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/etc/redis/redis.conf\u0026#34; ] networks: rd_net: name: rd_net 4、构建Redis节点 docker-compose -f \u0026#39;填写上述的compose文件名\u0026#39; up -d 5、进入启动的端口为7001的容器 docker exec -it container_id bash 6、集群搭建指令 redis-cli -p 7001 -a redispwd --cluster create 宿主机ip:7001 宿主机ip:7002 宿主机ip:7003 宿主机ip:7004 宿主机ip:7005 宿主机ip:7006 --cluster-replicas 1 示例 redis-cli -p 7001 -a 123456 --cluster create 192.168.0.108:7001 192.168.0.108:7002 192.168.0.108:7003 192.168.0.108:7004 192.168.0.108:7005 192.168.0.108:7006 --cluster-replicas 1 问题 # 如果出现一下输出,输入yes回车 [WARNING] Some slaves are in the same host as their master M: 410fa12d0ada0a4ed14e4c126f3e9239b85dff0b 192.168.0.108:7001 slots:[0-5460] (5461 slots) master M: e7ce1fe766193298b3c5d085df16afa28bface52 192.168.0.108:7002 slots:[5461-10922] (5462 slots) master M: ac84fa6c9c90a772c9d1480eecd02ea8bf1f6aa6 192.168.0.108:7003 slots:[10923-16383] (5461 slots) master S: 22170ca8d13560d0cee73f6b76f0269fb61b37ca 192.168.0.108:7004 replicates 410fa12d0ada0a4ed14e4c126f3e9239b85dff0b S: 5afd4a32f9e1db30cb7cb51332e8c58b1e5b9605 192.168.0.108:7005 replicates e7ce1fe766193298b3c5d085df16afa28bface52 S: c218a03566d007d47a794d7df9aba949517feccd 192.168.0.108:7006 replicates ac84fa6c9c90a772c9d1480eecd02ea8bf1f6aa6 Can I set the above configuration? (type \u0026#39;yes\u0026#39; to accept): 成功 \u0026gt;\u0026gt;\u0026gt; Performing Cluster Check (using node 192.168.0.108:7001) M: 410fa12d0ada0a4ed14e4c126f3e9239b85dff0b 192.168.0.108:7001 slots:[0-5460] (5461 slots) master 1 additional replica(s) S: c218a03566d007d47a794d7df9aba949517feccd 192.168.0.108:7006 slots: (0 slots) slave replicates ac84fa6c9c90a772c9d1480eecd02ea8bf1f6aa6 M: ac84fa6c9c90a772c9d1480eecd02ea8bf1f6aa6 192.168.0.108:7003 slots:[10923-16383] (5461 slots) master 1 additional replica(s) S: 22170ca8d13560d0cee73f6b76f0269fb61b37ca 192.168.0.108:7004 slots: (0 slots) slave replicates 410fa12d0ada0a4ed14e4c126f3e9239b85dff0b M: e7ce1fe766193298b3c5d085df16afa28bface52 192.168.0.108:7002 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: 5afd4a32f9e1db30cb7cb51332e8c58b1e5b9605 192.168.0.108:7005 slots: (0 slots) slave replicates e7ce1fe766193298b3c5d085df16afa28bface52 [OK] All nodes agree about slots configuration. \u0026gt;\u0026gt;\u0026gt; Check for open slots... \u0026gt;\u0026gt;\u0026gt; Check slots coverage... [OK] All 16384 slots covered. 查看搭建情况 # 进入任意容器，输入以下命令 # 进入Redis集群 redis-cli -p 7001 -a 123456 # 查看集群状态 cluster info # 查看集群节点信息 cluster nodes ","permalink":"https://yanyiup.com/posts/tech/%E4%BD%BF%E7%94%A8docker%E6%9E%84%E5%BB%BAredis%E9%9B%86%E7%BE%A4/","summary":"1、创建Redis集群配置文件模版。cluster-redis.conf # redis端口 port ${PORT} # ip bind 0.0.0.0 # 关闭本地访问保护模式 protected-mode no # 设置的密码 requirepass","title":"使用Docker构建Redis集群"},{"content":"Go语言设计和应用模式\n创作模式 建造者模式 建造者模式将复杂对象的构造与其表示分离，使得相同的构造过程可以创建不同的表示。\n在 Go 中，通常使用配置结构来实现相同的行为，但是将结构传递给构建器方法会使用样板 if cfg.Field != nil {...}检查填充代码\n示例 package car type Speed float64 const ( MPH Speed = 1 KPH = 1.60934 ) type Color string const ( BlueColor Color = \u0026#34;blue\u0026#34; GreenColor = \u0026#34;green\u0026#34; RedColor = \u0026#34;red\u0026#34; ) type Wheels string const ( SportsWheels Wheels = \u0026#34;sports\u0026#34; SteelWheels = \u0026#34;steel\u0026#34; ) type Builder interface { Color(Color) Builder Wheels(Wheels) Builder TopSpeed(Speed) Builder Build() Interface } type Interface interface { Drive() error Stop() error } 用法 assembly := car.NewBuilder().Paint(car.RedColor) familyCar := assembly.Wheels(car.SportsWheels).TopSpeed(50 * car.MPH).Build() familyCar.Drive() sportsCar := assembly.Wheels(car.SteelWheels).TopSpeed(150 * car.MPH).Build() sportsCar.Drive() 工厂模式 工厂方法创建设计模式允许创建对象而不必指定将要创建的对象的确切类型。\n示例实现展示了如何提供具有不同后端（例如内存、磁盘存储）的数据存储。\n示例 package data import \u0026#34;io\u0026#34; type Store interface { Open(string) (io.ReadWriteCloser, error) } type StorageType int const ( DiskStorage StorageType = 1 \u0026lt;\u0026lt; iota TempStorage MemoryStorage ) func NewStore(t StorageType) Store { switch t { case MemoryStorage: return newMemoryStorage( /*...*/ ) case DiskStorage: return newDiskStorage( /*...*/ ) default: return newTempStorage( /*...*/ ) } } 用法 s, _ := data.NewStore(data.MemoryStorage) f, _ := s.Open(\u0026#34;file\u0026#34;) n, _ := f.Write([]byte(\u0026#34;data\u0026#34;)) defer f.Close() 对象池模式 对象池创建设计模式用于根据需求预期准备和保留多个实例。\n对象池模式在对象初始化比对象维护更昂贵的情况下很有用。 如果需求出现峰值而不是稳定需求，则维护开销可能会超过对象池的好处。 由于预先初始化对象，它对性能有积极影响。 示例 package pool type Pool chan *Object func New(total int) *Pool { p := make(Pool, total) for i := 0; i \u0026lt; total; i++ { p \u0026lt;- new(Object) } return \u0026amp;p } 用法 p := pool.New(2) select { case obj := \u0026lt;-p: obj.Do( /*...*/ ) p \u0026lt;- obj default: // No more objects left — retry later or fail return } 单例模式 单例创建设计模式将类型的实例化限制为单个对象。\n单例模式表示全局状态，大多数时候会降低可测试性。 示例 package singleton type singleton map[string]string var ( once sync.Once instance singleton ) func New() singleton { once.Do(func() { instance = make(singleton) }) return instance } 用法 s := singleton.New() s[\u0026#34;this\u0026#34;] = \u0026#34;that\u0026#34; s2 := singleton.New() fmt.Println(\u0026#34;This is \u0026#34;, s2[\u0026#34;this\u0026#34;]) // This is that ","permalink":"https://yanyiup.com/posts/tech/go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F/","summary":"Go语言设计和应用模式 创作模式 建造者模式 建造者模式将复杂对象的构造与其表示分离，使得相同的构造过程可以创建不同的表示。 在 Go 中，通常使用配置结","title":"Go语言设计和应用模式"},{"content":"","permalink":"https://yanyiup.com/about/","summary":"","title":"个人信息"}]